class Solution {
public:
    /*先从nums的最后一个元素向前比较，如果nums[i] > nums[i - 1]，那么就互换两个位置的数,然后返回；如果遍历到nums[0]还没有符合条件的数，那么说明不存在下一个更大的排列，则将数字排列成最小的
    排列*/
    /*问题一：什么条件下可以换？-> nums[i] > nums[i - 1]时，需要换nums[i - 1]*/
    /*问题二：哪个和哪个位置互换？-> 需要和nums[i - 1]后面第一个比nums[i - 1]大的数互换*/
    void nextPermutation(vector<int>& nums) {
		if (nums.size() == 0 || nums.size() == 1) return;
		for (int i = nums.size() - 1; i > 0; i--) {
			if (nums[i] > nums[i - 1]) {
				for (int j = nums.size() - 1; j >= i; j--) {
					if (nums[j] > nums[i - 1]) {
						swap(nums[j], nums[i - 1]);
						reverse(nums.begin() + i, nums.end());//这一步我没想到
						return;
					}
				}
			}
		}
		sort(nums.begin(), nums.end());
		return;
	}
};

/*可以将这个题转化为：给定若干个数字，将其组合为一个整数。如果将这些数字重新排列，以得到下一个更大的整数，如123下一个更大的整数为132,如果没有更大的整数，则输出最小的整数*/
/*1.我们希望下一个数字比当前的数字大，这样才满足下一个排列的定义，因此只需要将后面的大数与前面的小数交换，就能得到一个更大的数 --> 从后向前查找第一个升序元素对
  2.我们还希望下一个数增加的幅度尽可能小，这样才满足“下一个排列与当前排列紧邻”的要求，为了满足这个要求，我们需要：
    1.尽可能在靠右的低位进行交换，需要从后向前查找
    2.将一个尽可能小的大数与前面的小数交换
    3.将大数置换到前面以后，需要将大数后面所有的数字升序排序*/